# Palindrome Checker â€“ Data Structures & Algorithm Evolution

## ğŸ“Œ Project Overview
This project demonstrates palindrome validation using different data structures and algorithmic techniques.

Each Use Case introduces a new computational concept to deepen understanding of problem-solving approaches.

---

## ğŸš€ Current Version: 9.0

---

## ğŸ“š Use Case Evolution

### UC4 â€“ Two Pointer Technique
- Compare first and last characters inward.
- Time: O(n)
- Space: O(1)

---

### UC5 â€“ Stack (LIFO)
- Reverse string using stack.
- Time: O(n)
- Space: O(n)

---

### UC6 â€“ Queue vs Stack
- Demonstrates FIFO vs LIFO behavior.
- Time: O(n)
- Space: O(n)

---

### UC7 â€“ Deque
- Double-ended access for direct comparison.
- Time: O(n)
- Space: O(n)

---

### UC8 â€“ Singly Linked List
- Fast & slow pointer technique.
- In-place reversal of second half.
- Time: O(n)
- Space: O(1)

---

### UC9 â€“ Recursion
- Recursive comparison of start and end characters.
- Base condition prevents infinite recursion.
- Uses call stack as underlying data structure.
- Time: O(n)
- Space: O(n) (due to call stack)

Demonstrates divide-and-conquer thinking and stack memory behavior.

---

## âš™ï¸ How to Run

1. Compile:
   javac PalindromeCheckerApp.java

2. Run:
   java PalindromeCheckerApp

---

## ğŸ§  Learning Outcome

- Iterative vs Recursive approaches
- Call stack behavior
- Base condition importance
- Space complexity analysis
- Structural comparison of data handling methods