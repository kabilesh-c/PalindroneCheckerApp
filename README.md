# Palindrome Checker â€“ Data Structures Evolution

## ğŸ“Œ Project Overview
This project demonstrates palindrome validation using different data structures and algorithmic techniques.

Each Use Case introduces a new structural concept to deepen understanding of efficiency and memory usage.

---

## ğŸš€ Current Version: 8.0

---

## ğŸ“š Use Case Evolution

### UC4 â€“ Two Pointer Technique
- Compare first and last characters inward.
- Time: O(n)
- Space: O(1)
- Most space-efficient approach.

---

### UC5 â€“ Stack (LIFO)
- Reverse string using stack.
- Operations: push(), pop()
- Time: O(n)
- Space: O(n)

---

### UC6 â€“ Queue vs Stack
- Demonstrates FIFO vs LIFO.
- Uses enqueue, dequeue, push, pop.
- Time: O(n)
- Space: O(n)

---

### UC7 â€“ Deque
- Double-ended access.
- addLast(), removeFirst(), removeLast()
- Eliminates need for separate structures.
- Time: O(n)
- Space: O(n)

---

### UC8 â€“ Singly Linked List
- Convert string to linked list.
- Fast & Slow pointer to find middle.
- In-place reversal of second half.
- Compare both halves.
- Time: O(n)
- Space: O(1) (no extra data structure used)

Demonstrates pointer manipulation and structural traversal without additional memory.

---

## âš™ï¸ How to Run

1. Compile:
   javac PalindromeCheckerApp.java

2. Run:
   java PalindromeCheckerApp

---

## ğŸ§  Learning Outcome

- Stack vs Queue vs Deque
- Linked List traversal
- Fast and slow pointer technique
- In-place reversal logic
- Space complexity comparison